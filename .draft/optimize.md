# KT.js `ref` 优化笔记（Class vs 闭包对象、JIT、Deopt）

## 1）先说结论

在框架运行时（`ref` 实例多、更新频繁）的场景下，`ref` 这种基础数据结构更建议用：

- **class + 原型方法**

而不是：

- “工厂函数 + 闭包对象”

核心原因：

- 方法共享（挂在 prototype 上），每个实例更省内存
- 调用点和对象形状更稳定，更利于 JIT 优化
- 大量实例时，GC 压力更小

闭包对象也有价值（封装/私有性好），但通常不是高频响应式原语的默认最优解。

---

## 2）Class 与闭包对象对比

### A. Class 风格（当前 `ref.ts`）

- 实例主要保存数据字段（`_value`、`_onChanges`）
- 方法共享（`addOnChange`、`notify`、`mutate` 等）
- 单实例分配成本较低

### B. 闭包对象风格

- 每创建一个实例，就会新建一组函数（`getValue`、`setValue` 等）
- 每个函数都捕获词法环境
- 私有性更强，但分配和 GC 成本更高

### C. 实战影响

- 少量对象时差距不一定明显
- 框架级高频场景（成百上千个 ref）下，class 通常更稳、更省

---

## 3）术语解释（含你关心的 deopt）

### JIT（Just-In-Time，即时编译）

JS 引擎不会只用一种执行方式。通常是：

- 先快速解释/基线编译
- 运行时收集热点信息后再做深度优化

目标是让热路径越来越快。

### 热路径（Hot Path）

执行频率非常高的代码路径。  
例如 `ref.value` 的 getter/setter、回调分发等。

### Hidden Class / Shape（隐藏类 / 对象形状）

引擎内部对“对象字段布局”的描述。

- 同类对象形状稳定：更容易优化
- 形状频繁变化：优化困难

### IC（Inline Cache，内联缓存）

引擎在调用点缓存“上次访问是什么形态”。

- **Monomorphic（单态）**：一种形态，最好
- **Polymorphic（多态）**：少量几种，通常还行
- **Megamorphic（超多态）**：太多种，性能会变差

### Inlining（内联）

把小函数直接“展开”到调用点，减少函数调用开销。

### GC Pressure（GC 压力）

临时对象太多会让垃圾回收更频繁，可能导致卡顿。

### Deopt（De-optimization，反优化）

你最关心这个，简单说就是：

- 引擎已经把一段热代码优化过了
- 但运行时发现原先的优化前提不成立了
- 引擎只好退回到较慢的执行层级

这个“从快路径退回”的过程就叫 **deopt**。  
例如：原来调用点一直很稳定，后来对象形状和类型频繁抖动，就容易触发 deopt。

---

## 4）常见触发 deopt / 性能退化的情况

以下在响应式系统里比较常见：

- 对象创建后又频繁增删字段（形状不稳定）
- 同一热字段在不同类型间频繁切换
- 同一调用点出现太多不同接收者（变成 megamorphic）
- 热路径里动态改 prototype / 函数实现
- setter/更新路径中产生大量临时对象

注意：不同 JS 引擎细节不同（V8 / SpiderMonkey / JSC），但这些规则普遍有效。

---

## 5）针对 `ref.ts` 的优化检查清单

### 5.1 保持对象形状稳定

- 核心字段在构造阶段一次性初始化
- 避免在热对象上 `delete`
- 避免在热路径里临时新增实例字段

### 5.2 方法尽量放到 prototype

- 不要每个实例都动态创建方法
- 不要在运行时频繁替换实例方法

### 5.3 热 setter 要短小

- 分支尽量少
- 尽量少临时分配
- 重逻辑放到热路径外

### 5.4 回调分发保持朴素

- 用数组 + `for` 索引循环（当前做法是好的）
- 避免在内层循环临时创建闭包/迭代器对象

### 5.5 原地修改数组/对象时

建议显式触发：

- `notify()`：手动通知
- `mutate(fn)`：在 `fn` 内原地改，退出后通知一次

这能保持语义清晰，也避免 Proxy 或 monkey patch 的复杂性。

---

## 6）为什么不默认选 Proxy 或覆盖原生数组方法

### Proxy 方案

优点：

- `push/splice/index=` 都可自动拦截，语法自然

缺点：

- 运行时复杂度与成本更高
- 可调试性和行为一致性更难控制
- 对旧环境兼容不友好

### 覆盖数组原生方法（包一层 push/splice）

优点：

- 用起来接近原生数组

缺点：

- 边界情况多（数组替换、外部数组、第三方对象）
- 维护成本高
- 行为一致性容易被破坏

对 KT.js 的“手动控制更新”理念来说，`notify/mutate` 是更稳妥的折中。

---

## 7）推荐使用方式

```ts
const list = ref<number[]>([1, 2, 3]);

// 推荐：原地改 + 一次通知
list.mutate((arr) => {
  arr.push(4);
  arr.splice(0, 1);
});

// 也可以：手动通知
list.value.push(5);
list.notify();
```

---

## 8）基准测试建议（避免误判）

比较 class vs 闭包对象时，建议：

- 先 warmup（预热）再测
- 用真实负载（大量 ref + 多轮更新），不要只测玩具例子
- 同时看吞吐和内存/GC，不只看 ops/s
- 多轮采样，避免一次性结论

真实业务表现比微基准里 1%~3% 的波动更重要。
